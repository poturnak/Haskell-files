{-
=====DATA TYPES INTRO=====
To define your own type you use the data keyword
    
    data Bool = False | True 

Before =: type constructor
After =: value constructor (values type can take, or how to construct the value for the type)

Both value and type constructors need to be capitalized.

Another example:
    data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving Show

Circle value constructor takes 3 floats whereas Rectangle takes 4.
In this example value constructors are functions that return type values.
For these value constructor functions you can map them, partially appy them as well. 
Deriving Show makes our class an instance of Show, therefore, haskell knows how to print it to screen

You can also pattern match on values generated by value constructors.

    surface :: Shape -> Float  
    surface (Circle _ _ r) = pi * r ^ 2  
    surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)

You can also export data types as part of modules. In () you add the value constructors to export. ... means all of them.

    module Shapes   
    ( Point(..)  
    , Shape(..)  
    , baseCircle  
    , baseRect  
    ) where

=====RECORD SYNTAX=====
There is the record syntax for defining the types where you have multiple values:
Here we first use the name of the field and then the type of the field.
Haskell will automatically create the functions to lookup the fields. 

    data Person = Person { firstName :: String  
                         , lastName :: String  
                         , age :: Int  
                         , height :: Float  
                         , phoneNumber :: String  
                         , flavor :: String  
                         } deriving (Show)

You can use age Person to get the age of the person. 

=====TYPE PARAMETERS=====
Much like value constructors can take parameters to produce values, type constructors can take types to produce new types. 
This way you can make your classes polymorphic.
The a here is a type parameter. 

data Maybe a = Nothing | Just a

=====DERIVED INSTANCES=====
Haskell can derive the behavior of our types in these contexts if we use the deriving keyword when making our data type.

    data Person = Person { firstName :: String  
                         , lastName :: String  
                         , age :: Int  
                         } deriving (Eq, Read, Show)

Read is pretty much the inverse typeclass of Show. Show is for converting values of our a type to a string, Read is for converting strings to values of our type. 
    
    ghci> read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" :: Person  
    Person {firstName = "Michael", lastName = "Diamond", age = 43}

=====TYPE SYNONIMS=====
Type synonyms don't really do anything per se, they're just about giving some types different names so that they make more sense to someone reading our code and documentation.
That is done with the TYPE keyword.

    type PhoneNumber = String  
    type Name = String  
    type PhoneBook = [(Name,PhoneNumber)]

Type synonims can also be parameterized
    
    type AssocList k v = [(k,v)]

Another cool data type is Either a b type. It is used when you want to mix 2 types returned by a fucntion.

    data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)

Example for Either type:
    
    import qualified Data.Map as Map  
    data LockerState = Taken | Free deriving (Show, Eq)  
    type Code = String  
    type LockerMap = Map.Map Int (LockerState, Code)

    lockerLookup :: Int -> LockerMap -> Either String Code  
    lockerLookup lockerNumber map =   
        case Map.lookup lockerNumber map of   
            Nothing -> Left $ "Locker number " ++ show lockerNumber ++ " doesn't exist!"  
            Just (state, code) -> if state /= Taken   
                                    then Right code  
                                    else Left $ "Locker " ++ show lockerNumber ++ " is already taken!"  
    
=====RECURSIVE DATA STRUCTURES=====
For example here is how we can define the list type:

    data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)  

We can define functions to be automatically infix by making them comprised of only special characters.
A fixity states how tightly the operator binds and whether it's left-associative or right-associative.

    infixr 5 :-:  
    data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)

Let's implement the binary search tree. 

    data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) 

    singleton :: a -> Tree a  
    singleton x = Node x EmptyTree EmptyTree  
  
    treeInsert :: (Ord a) => a -> Tree a -> Tree a  
    treeInsert x EmptyTree = singleton x  
    treeInsert x (Node a left right)   
        | x == a = Node x left right  
        | x < a  = Node a (treeInsert x left) right  
        | x > a  = Node a left (treeInsert x right)

    treeElem :: (Ord a) => a -> Tree a -> Bool  
    treeElem x EmptyTree = False  
    treeElem x (Node a left right)  
        | x == a = True  
        | x < a  = treeElem x left  
        | x > a  = treeElem x right

=====TYPECLASSES=====
A typeclass defines some behavior (like comparing for equality, comparing for ordering, enumeration) and then types that can behave in that way are made instances of that typeclass.
The behavior of typeclasses is achieved by defining functions or just type declarations that we then implement. So when we say that a type is an instance of a typeclass, we mean that we can use the functions that the typeclass defines with that type.

1. We define the typeclass (i.e. Eq typeclass)

    class Eq a where  
        (==) :: a -> a -> Bool  
        (/=) :: a -> a -> Bool  
        x == y = not (x /= y)  
        x /= y = not (x == y)

2. We define our classes using data keyword

    data TrafficLight = Red | Yellow | Green  

3. We create the instance of the class for our defined types (class is for making typeclasses, instance is for making our types instances of the typeclass)

    instance Eq TrafficLight where  
        Red == Red = True  
        Green == Green = True  
        Yellow == Yellow = True  
        _ == _ = False

    instance Show TrafficLight where  
        show Red = "Red light"  
        show Yellow = "Yellow light"  
        show Green = "Green light"

    Because == was defined in terms of /= and vice versa in the class declaration, we only had to overwrite one of them in the instance declaration. That's called the minimal complete definition for the typeclass â€” the minimum of functions that we have to implement so that our type can behave like the class advertises.

For maybe you  can do the following:
    instance Eq (Maybe m) where  
        Just x == Just y = x == y  
        Nothing == Nothing = True  
        _ == _ = False  

We can also put class constraint on class declaration:

    class (Eq a) => Num a where  
       ...

Most of the times, class constraints in class declarations are used for making a typeclass a subclass of another typeclass and class constraints in instance declarations are used to express requirements about the contents of some type.

=====FUNCTOR TYPECLASS=====
Functor type class is for things that can be mapped over.

Functor is a parametrized type that is an instance of the Functor typeclass. 
That means fmap is implemented for that type. 
fmap is the generelized version of map for parametrized types. 

    class Functor f where  
        fmap :: (a -> b) -> f a -> f b

Types that can act like a box can be functors.
Here is how Maybe is a functor:
    
    instance Functor Maybe where  
        fmap f (Just x) = Just (f x)  
        fmap f Nothing = Nothing

    instance Functor Tree where  
        fmap f EmptyTree = EmptyTree  
        fmap f (Node x leftsub rightsub) = Node (f x) (fmap f leftsub) (fmap f rightsub)

    instance Functor (Either a) where  
        fmap f (Right x) = Right (f x)  
        fmap f (Left x) = Left x

=====KINDS=====
A kind is more or less the type of a type.

    ghci> :k Int  
    Int :: *

A * means that the type is a concrete type.

    ghci> :k Maybe  
    Maybe :: * -> *

The Maybe type constructor takes one concrete type (like Int) and then returns a concrete type like Maybe Int

-}

import qualified Data.Map as Map 

data List a = Empty2 | Cons a (List a) deriving (Show, Read, Eq, Ord)  

data Point = Point Float Float | Empty deriving (Show)  
data Shape = Circle Point Float | Rectangle Point Point deriving (Show) 

surface :: Shape -> Float  
surface (Circle _ r) = pi * r ^ 2  
surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1) 

nudge :: Shape -> Float -> Float -> Shape  
nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r  
nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+b)) 

multiplyPoint:: Point -> Float
multiplyPoint (Point a b) = a*b

point1 = Point 4 5

-- let's define the data type that defines a person

data Person = Person { firstName :: String  
                     , lastName :: String  
                     , age :: Int  
                     } deriving (Show)

person1 = Person {firstName="Nikolay", lastName="Poturnak", age=31}
 -- now you can directly use the functions that Haskell defined for us
 -- firstName person1 will return "Nikolay"
 -- etc.

-- =====Type parameters=====

data Maybe a = Nothing | Just a



-- type constructor Maybe takes a as an input, can be Int, Char, etc.
{- Let's implement a 3D vector type and add some operations for it.
We'll be using a parameterized type because even though it will
usually contain numeric types, it will still support several of them.

-}

data Vector a = Vector a a a deriving (Show)  
  
vplus :: (Num t) => Vector t -> Vector t -> Vector t  
(Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)  
  
vectMult :: (Num t) => Vector t -> t -> Vector t  
(Vector i j k) `vectMult` m = Vector (i*m) (j*m) (k*m)  
  
scalarMult :: (Num t) => Vector t -> Vector t -> t  
(Vector i j k) `scalarMult` (Vector l m n) = i*l + j*m + k*n 

-- deriving helps us auto include our class as the instance of type class

data Person1 = Person1 { firstName1 :: String  
                     , lastName1 :: String  
                     , age1 :: Int  
                     } deriving (Eq)  

-- There's only one catch though, the types of all the fields also have to be part of the Eq typeclass.

-- Read is pretty much the inverse typeclass of Show. Show is for converting values of our a type to a string, Read is for converting strings to values of our type. Remember though, when we use the read function, we have to use an explicit type annotation to tell Haskell which type we want to get as a result. If we don't make the type we want as a result explicit, Haskell doesn't know which type we want.

-- read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" :: Person  

-- Type synonyms don't really do anything per se, they're just about giving some types different names so that they make more sense to someone reading our code and documentation.

-- type keyword is used to make type synonims
-- type String = [Char] 

-- use type either a b if you want to return things of different type within a function
-- data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)

 {-
  
data LockerState = Taken | Free deriving (Show, Eq)  
  
type Code = String  
  
type LockerMap = Map.Map Int (LockerState, Code)  

lockerLookup :: Int -> LockerMap -> Either String Code  
lockerLookup lockerNumber map =   
    case Map.lookup lockerNumber map of   
        Nothing -> Left $ "Locker number " ++ show lockerNumber ++ " doesn't exist!"  
        Just (state, code) -> if state /= Taken   
                                then Right code  
                                else Left $ "Locker " ++ show lockerNumber ++ " is already taken!"  

-}

-- now we are going to implement binary search tree


-- =====EXAMPLE OF A YES NO CLASS=====
{-class YesNo a where  
    yesno :: a -> Bool 

instance YesNo Int where  
    yesno 0 = False  
    yesno _ = True

instance YesNo [a] where  
    yesno [] = False  
    yesno _ = True

instance YesNo Bool where  
    yesno = id

instance YesNo (Maybe a) where  
    yesno (Just _) = True  
    yesno Nothing = False

yesnoIf :: (YesNo y) => y -> a -> a -> a  
yesnoIf yesnoVal yesResult noResult = if yesno yesnoVal then yesResult else noResult  

-}





